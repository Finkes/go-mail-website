[{"id":0,"href":"/de/getting-started/introduction/","title":"Einführung","parent":"Erste Schritte","content":"Diese kurze Anleitung zeigt dir, wie du go-mail von der Installation bis zum Versand deiner ersten Mail nutzen kannst.\nVoraussetzungen Installation Deine erste Mail verschicken Eine neue Nachricht erstellen Versenden der Mail Zusammenfassung Vollständiger Beispielcode Voraussetzungen go-mail erfordert eine funktionierende Go-Installation (Version 1.16+). Lade Go von der Go Downloads Seite.\nInstallation go-mail kann über den Go-Modul-Installationsmechanismus mit dem Befehl go get installiert werden.\nUm die neueste Version von go-mail zu installieren, gehst du in deinen Projektordner und importierst das Modul einfach mit dem folgenden Befehl:\n1 $ go get github.com/wneessen/go-mail Deine erste Mail verschicken go-mail besteht aus zwei Hauptkomponenten. Die Msg, die die Mail-Nachricht darstellt und der Client, der sich um die Mail-Zustellung über einen SMTP-Dienst kümmert.\nEine neue Nachricht erstellen Zuerst erstellen wir eine neue Msg mit der Methode NewMsg() und weisen eine Absender- und eine Empfängeradresse zu.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;github.com/wneessen/go-mail\u0026#34; \u0026#34;log\u0026#34; ) func main() { m := mail.NewMsg() if err := m.From(\u0026#34;toni.sender@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set From address: %s\u0026#34;, err) } if err := m.To(\u0026#34;tina.recipient@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set To address: %s\u0026#34;, err) } } In diesem kleinen Codeschnipsel importieren wir zuallererst go-mail in unser Projekt. Siehe die Import-Anweisung in Zeile 4. Als nächstes erstellen wir eine neue Nachricht in Zeile 9. In den Zeilen 10 und 13 werden die Absender- und Empfängeradressen festgelegt. Da go-mail sicherstellt, dass du gültige Mailadressen angibst, geben wir einen error zurück. Auf diese Weise können wir sicherstellen, dass die angegebene Adresse von go-mail akzeptiert wird und später keine Probleme verursacht.\nAls Nächstes wollen wir eine Betreffzeile für unsere Nachricht festlegen und den Mailtext mit einem Inhalt füllen.\n1 2 m.Subject(\u0026#34;Das ist meine erste Mail mit go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Gefällt dir diese Mail? Mir auf jeden Fall!\u0026#34;) Das erste Argument für SetBodyString() ist ein Inhaltstyp, den wir angeben müssen. In unserem Beispiel repräsentiert der mail.TypeTextPlain einen text/plain Inhaltstyp - also einen reinen Textkörper.\nVersenden der Mail Jetzt, wo wir unsere E-Mail-Nachricht versandfertig haben, können wir sie auf den Weg bringen und verschicken. Hierfür verwenden wir den Client, der die SMTP-Übertragung abwickelt.\n1 2 3 4 5 c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } In diesem Beispiel verbinden wir uns mit dem Mailserver hinter dem Hostnamen smtp.example.com und geben dem Client ein paar Optionen wie den Port, mit dem wir uns verbinden wollen, die Tatsache, dass wir SMTP PLAIN für die Authentifizierung verwenden wollen und den Benutzernamen und das Passwort, mit.\nAbschließend weisen wir den Client an, die Mail zuzustellen.\n1 2 3 if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } Die Methode DialAndSend() kümmert sich um den Aufbau der Verbindung und den Versand der Mail. Du kannst sie auch separat aufrufen, aber das benötigen wir für dieses kurze Beispiel nicht.\nZusammenfassung Das war doch ganz einfach, oder? Du hast erfolgreich eine E-Mail-Nachricht vorbereitet und sie dem Empfänger über einen Mailserver eines Drittanbieters zugestellt. go-mail kann natürlich noch viel mehr. In der ausführlichen Dokumentation findest du alle Funktionen.\nVollständiger Beispielcode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;github.com/wneessen/go-mail\u0026#34; \u0026#34;log\u0026#34; ) func main() { m := mail.NewMsg() if err := m.From(\u0026#34;toni.sender@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set From address: %s\u0026#34;, err) } if err := m.To(\u0026#34;tina.recipient@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set To address: %s\u0026#34;, err) } m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Gefällt dir diese Mail? Mir auf jeden Fall!\u0026#34;) c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } } "},{"id":1,"href":"/de/getting-started/","title":"Erste Schritte","parent":"Willkommen in der go-mail-Dokumentation","content":""},{"id":2,"href":"/de/reference/","title":"Referenz","parent":"Willkommen in der go-mail-Dokumentation","content":""},{"id":3,"href":"/de/reference/client/options/","title":"Client-Optionen","parent":"Der Client für die Mailzustellung","content":" Option WithDSN() WithDSNMailReturnType() WithDSNRcptNotifyType() WithHELO() Option Signature 1 type Option func(*Client) error Client Option sind Funktionen, die als optionale Argumente für die NewClient() Methoden verwendet werden können, um die Standardeinstellungen des zurückgegebenen Client zu überschreiben.\nWithDSN() Signature 1 func WithDSN() Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSN()) if err != nil { panic(err) } } Die WithDSN Optionsfunktion weist den Client an, DSNs anzufordern (wenn der Server sie unterstützt), wie in RFC 1891 beschrieben.\nDSNs (Delivery Status Notification) sind eine Erweiterung des SMTP-Protokolls und müssen von dem sendenden Server unterstützt werden. Der RFC für DSNs definiert verschiedene Parameter, von denen wir einmal die implementiert haben, die wir für go-mail für am sinnvollsten halten:\nDie RET-Erweiterung für den MAIL FROM-Befehl, damit der Benutzer angeben kann, ob ein DSN die vollständige Mail (FULL) oder nur die Kopfzeilen (HDRS) der gesendeten Mail enthalten soll. Die NOTIFY-Erweiterung, die es dem Benutzer ermöglicht, einen DSN für die verschiedenen Arten von erlaubten Situationen anzufordern: NEVER, SUCCESS, FAILURE und DELAY ENVID und ORCPT werden derzeit nicht unterstützt, könnten aber in einer späteren Version folgen (bitte eröffne ein Issue, wenn du darin einen Nutzen siehst).\nStandardmäßig setzt WithDSN() die FULL Mail From Return Option und die SUCCESS und FAILURE Recipient Notify Optionen. Wenn du andere Einstellungen für den DSN verwenden möchtest, lies bitte die Dokumentation für WithDSNMailReturnType und WithDSNRcptNotifyType\nWithDSNMailReturnType() Signature 1 func WithDSNMailReturnType(DSNMailReturnOption) Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSNMailReturnType(mail.DSNMailReturnFull)) if err != nil { panic(err) } } WithDSNMailReturnType ermöglicht es dem Client, DSNs anzufordern (wenn der Server es unterstützt), wie in der RFC 1891 beschrieben und den MAIL FROM Rückgabeoptionstyp auf die angegebene DSNMailReturnOption\ngo-mail hat die folgenden zwei DSNMailReturnOption Typen bereits eingebaut:\nDSNMailReturnHeadersOnly: verlangt, dass nur die Kopfzeilen der Nachricht zurückgegeben werden. Siehe: RFC 1891, Abschnitt 5.3 DSNMailReturnFull: fordert an, dass die gesamte Nachricht in jeder \u0026ldquo;fehlgeschlagenen\u0026rdquo; Zustellungsstatus-Benachrichtigung, die für diesen Empfänger ausgegeben wird, zurückgegeben wird Siehe: RFC 1891, Abschnitt 5.3 WithDSNRcptNotifyType() Signature 1 func WithDSNRcptNotifyType(...DSNRcptNotifyOption) Option Example 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSNRcptNotifyType(mail.DSNRcptNotifyFailure, mail.DSNRcptNotifyDelay, mail.DSNRcptNotifySuccess)) if err != nil { panic(err) } } WithDSNRcptNotifyType ermöglicht dem Client, DSNs wie in RFC 1891 beschrieben anzufordern und setzt die RCPT TO Notify-Optionen auf die angegebene Liste von DSNRcptNotifyOption\ngo-mail hat die folgenden DSNRcptNotifyOption Typen bereits eingebaut:\nDSNRcptNotifyNever: fordert, dass ein DSN unter keinen Umständen an den Absender zurückgeschickt wird. Siehe: RFC 1891, Abschnitt 5.1 DSNRcptNotifySuccess: fordert an, dass ein DSN bei erfolgreicher Übergabe ausgegeben wird Siehe: RFC 1891, Abschnitt 5.1 DSNRcptNotifyFailure: fordert an, dass ein DSN bei Zustellungsfehler ausgegeben wird Siehe: RFC 1891, Abschnitt 5.1 DSNRcptNotifyDelay: gibt die Bereitschaft des Senders an, \u0026ldquo;verzögerte\u0026rdquo; DSNs zu empfangen. Verspätete DSNs können ausgestellt werden, wenn sich die Zustellung einer Nachricht um eine ungewöhnliche Zeitspanne verzögert hat (wie vom MTA bestimmt, bei dem die Nachricht verzögert wurde), aber der endgültige Zustellungsstatus (ob erfolgreich oder nicht) nicht ermittelt werden kann. Das Fehlen des Schlüsselworts DELAY in einem NOTIFY-Parameter bedeutet, dass unter keinen Umständen ein \u0026ldquo;verzögerter\u0026rdquo; DSN ausgegeben werden darf. Siehe: RFC 1891, Abschnitt 5.1 WithHELO() Signature 1 func WithHELO(string) Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithHELO(\u0026#34;test.example.com\u0026#34;)) if err != nil { panic(err) } } WithHELO weist den Client an, die angegebene Zeichenkette als HELO/EHLO Begrüßungshost zu verwenden. Standardmäßig verwendet der Client die Methode os.Hostname() von Go, um den lokalen Hostnamen zu ermitteln und diesen für die HELO/EHLO-Begrüßung zu verwenden. WithHELO wird dies außer Kraft setzen.\n"},{"id":4,"href":"/de/community/","title":"Communities","parent":"Willkommen in der go-mail-Dokumentation","content":""},{"id":5,"href":"/de/community/guide/","title":"Community-Leitfaden","parent":"Communities","content":"Die go-mail-Community wächst und wenn Du dies liest, stehen die Chancen gut, dass Du auch mitmachen willst!\nRessourcen Verhaltenskodex Support- und Ankündigungskanäle Mitwirken Entwicklung neuer Funktionen Fehler beheben Testen Dokumentation Übersetzungen Unterstützen Ressourcen Verhaltenskodex In unserer Community folgen wir dem Verhaltenskodex und verlangen von jedem, der Teilnehmen möchte, sich ebenso zu verhalten.\nSupport- und Ankündigungskanäle Twitter: Folge uns auf Twitter, um aktuelle Nachrichten über go-mail zu erhalten go-mail Forum: Erhalte Ankündigungen und starte Diskussionen über go-mail. Github Tickets: Wenn Du einen Bug melden oder ein Feature vorschlagen möchtest, benutze bitte die Github \u0026ldquo;Issues\u0026rdquo; Funktion. Bitte beachte die Regeln, die in jedem Projektarchiv-Template angegeben sind. Discord: Ein Platz, wo go-mail Entwickler und Nutzer sich treffen können und in Echtzeit chatten können. Mitwirken go-mail ist ein Open-Source-Projekt, das von der Community betrieben wird. Wir begrüßen jeden, der mit uns an diesem Projekt mitwirkt. Diese Dokumentation richtet sich an alle, die sich mit dem Projekt und den Entwicklungsprozessen vertraut machen möchten.\nEntwicklung neuer Funktionen Fehler beheben Testen Dokumentation Übersetzungen Unterstützen Entwicklung neuer Funktionen Wir sind immer daran interessiert, Funktionen zu go-mail hinzuzufügen. Der Prozess zum Hinzufügen neuer Funktionen lautet wie folgt:\nSchau im Issue-Bereich auf Github nach verfügbaren Issues mit dem Tag \u0026ldquo;TODO\u0026rdquo; oder \u0026ldquo;help wanted\u0026rdquo; Wenn kein offenes \u0026ldquo;TODO\u0026rdquo;/\u0026ldquo;Hilfe gesucht\u0026rdquo;-Thema gefunden wird oder die Funktion, die du im Sinn hast, nicht abgedeckt ist, mach bitte ein Issue für diese spezielle Funktion auf und warte auf das \u0026ldquo;OK\u0026rdquo; der Maintainers Überprüfe vor der Entwicklung, ob die Ausgabe die folgenden Informationen enthält: Der Zweck der Erweiterung Was für die Verbesserung nicht in Frage kommt Wenn das Issue diese Informationen nicht enthält, kannst du sie bei der Person, die das Issue eröffnet hat, anfordern. Manchmal werden Platzhalterausgaben erstellt und erfordern mehr Details Kommentiere das Thema und gib an, ob du die Funktion entwickeln möchtest Klone das Repository und erstelle einen Zweig mit dem Format feature/\u0026lt;issue_number\u0026gt;_\u0026lt;issue_title\u0026gt; Neue Funktionen erfordern oft eine Dokumentation, also stelle bitte sicher, dass du die Dokumentation als Teil der Änderungen auch hinzugefügt oder aktualisiert hast Bitte stelle sicher, dass dein Code die erforderliche Testabdeckung hat Sobald die Funktion zum Testen bereit ist, erstellst du einen PR-Entwurf. Bitte stelle sicher, dass in der PR-Beschreibung die Testszenarien und Testfälle mit Häkchen aufgeführt sind, damit andere wissen, was noch getestet werden muss Sobald alle Tests abgeschlossen sind, aktualisiere bitte den Status des PR von Entwurf und hinterlasse eine Nachricht Alle PRs, die ohne eine entsprechende Ausgabe eröffnet werden, können abgelehnt werden. Fehler beheben Das Verfahren zur Behebung von Fehlern ist wie folgt:\nÜberprüfe die Github Issues und wähle einen Fehler zum Beheben aus Überprüfe vor der Entwicklung, ob das Issue die folgenden Informationen enthält: Der Umfang des Problems einschließlich der betroffenen Plattformen Die Schritte zum Reproduzieren. Manchmal werden Bugs geöffnet, die keine go-mail Probleme sind, und der Berichterstatter muss anhand eines minimalen, reproduzierbaren Beispiels beweisen, dass es sich um ein go-mail Problem handelt Wenn das Problem diese Informationen nicht enthält, kannst du sie bei der Person, die das Problem eröffnet hat, anfordern Kommentiere das Issue und gib an, dass du eine Lösung entwickeln möchtest Klone das Repository und erstelle einen Branch mit dem Format bugfix/\u0026lt;issue_number\u0026gt;_\u0026lt;issue_title\u0026gt; Sobald die Korrektur zum Testen bereit ist, erstellst du einen PR-Entwurf. Bitte stelle sicher, dass in der PR-Beschreibung die Testszenarien und Testfälle mit Häkchen aufgeführt sind, damit andere wissen, was noch getestet werden muss Sobald alle Tests abgeschlossen sind, aktualisiere bitte den Status des PR von Entwurf und hinterlasse eine Nachricht. Es hält dich nichts davon ab, ein Issue zu öffnen und selbst daran zu arbeiten, aber sei dir bitte bewusst, dass alle Fehlerbehebungen besprochen werden sollten, da der Ansatz unbeabsichtigte Nebenwirkungen haben kann. Alle PRs, die ohne eine entsprechende Ausgabe eröffnet werden, können abgelehnt werden. Testen Das Testen ist von entscheidender Bedeutung, um die Qualität des Projekts sicherzustellen. Es gibt ein paar Szenarien, in denen das Testen dem Projekt wirklich helfen kann:\nTesten, ob ein Fehler auf deinem lokalen System reproduzierbar ist PRs testen, um sicherzustellen, dass sie richtig funktionieren Wenn du testen möchtest, ob die Fehlermeldung eines anderen Nutzers auf deinem System reproduzierbar ist, kannst du einen Kommentar zu der Meldung hinzufügen, der dies mit der Ausgabe deines Testprogramms bestätigt.\nUm PRs zu testen, wählst du einen PR zum Testen aus und überprüfst, ob in der PR-Beschreibung die Testszenarien aufgeführt sind. Wenn nicht, bitte die Person, die den PR eröffnet hat, diese Liste zur Verfügung zu stellen. Wenn du ein gültiges Testszenario ermittelt hast, melde deine Ergebnisse bitte in der PR.\nWenn du mehr Informationen oder Hilfe beim Testen brauchst, kannst du im Github-Forum oder auf Discord eine Frage stellen.\nDokumentation Während wir eine ordentliche GoDoc-Dokumentation mit Kommentaren im Code verlangen, ist diese Website für eine ausführlichere Dokumentation der Funktionen und des Projekts selbst gedacht.\nDa das Thema \u0026ldquo;Dokumentation\u0026rdquo; immer schwierig ist und die Website noch unvollständig ist, ist jeder Beitrag dazu sehr willkommen. Funktionen ohne Dokumentation gelten für das Projekt als \u0026ldquo;unvollendet\u0026rdquo;, sie sind genauso wichtig wie der Code.\nDie Website wurde mit Hugo und dem Geekdocs-Theme erstellt. Es ist sehr einfach und besteht im Wesentlichen aus Markdown-Dateien. Im Repository der Website findest du eine Anleitung, wie du die Website auf deinem lokalen Computer installieren kannst.\nÜbersetzungen Die Standarddokumente des go-mail-Projekts sind englische Dokumente. Wir verwenden das Tool \u0026ldquo;Crowdin\u0026rdquo;, um Dokumente in andere Sprachen zu übersetzen und sie mit der Website zu synchronisieren. Du kannst unserem Projekt beitreten und deine Übersetzungen einreichen, um einen Beitrag zu leisten.\nDerzeit ist die einzige unterstützte zweite Sprache Deutsch, aber wir sind daran interessiert, auch andere Sprachen hinzuzufügen. Bitte beantrage sie über ein Github-Problem im go-mail-website Repository.\nUnterstützen Eine gute Möglichkeit, zum Projekt beizutragen, ist es, anderen zu helfen, die Schwierigkeiten haben. Dies wird normalerweise als GH-Issue oder als Nachricht im #go-mail Discord-Kanal gemeldet. Schon die Klärung des Problems kann sehr hilfreich sein. Manchmal, wenn ein Problem diskutiert und gelöst wird, erstellen wir daraus einen Leitfaden, um anderen zu helfen, die mit den gleichen Problemen konfrontiert sind.\n"},{"id":6,"href":"/de/reference/client/","title":"Der Client für die Mailzustellung","parent":"Referenz","content":"In go-mail ist der Client für die Mailzustellung mit entfernten Mailservern zuständig, die über das SMTP-Protokoll kommunizieren.\nNewClient() Client Close() DialAndSend() DialAndSendWithContext() NewClient() Signature 1 func NewClient(string, ...Option) (*Client, error) Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;) if err != nil { panic(err) } } Um einen neuen Client zu erstellen, kannst du die Methode NewClient() verwenden. Als erstes Argument benötigt er den Hostnamen des sendenden SMTP-Servers. Optional kannst du eine Liste von Option-Funktionen angeben. Diese Optionsfunktionen können verwendet werden, um die Standardeinstellungen des Client zu überschreiben.\nIn der Optionen Dokumentation findest du ausführliche Informationen zu allen verfügbaren Optionen.\nClient Signature 1 2 3 type Client struct { // contains filtered or unexported fields } Close() Signature 1 func (*Client) Close() error Example 1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;) if err != nil { panic(err) } defer c.Close() } Close() schließt die Verbindung zu dem SMTP-Server, mit dem der Client verbunden ist. Sie gibt einen error zurück, wenn der Client keine aktive Verbindung hat oder wenn das Schließen der Verbindung fehlschlägt.\nDialAndSend() Signature 1 func (*Client) DialAndSend(...*Msg) error Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { from := \u0026#34;Toni Tester \u0026lt;toni@example.com\u0026gt;\u0026#34; to := \u0026#34;Alice \u0026lt;alice@example.com\u0026gt;\u0026#34; server := \u0026#34;mail.example.com\u0026#34; m := mail.NewMsg() if err := m.From(from); err != nil { panic(err) } if err := m.To(to); err != nil { panic(err) } m.Subject(\u0026#34;This is a great subject\u0026#34;) c, err := mail.NewClient(server) if err != nil { panic(err) } if err := c.DialAndSend(m); err != nil { panic(err) } } Die Methode DialAndSend() ist ein Alias für DialAndSendWithContext() mit einem Standardkontext context.Background. DialAndSend() nimmt eine Liste von Msg Pointern als Argument(e) und gibt einen error zurück, wenn eine der durchgeführten Aktionen fehlschlägt.\nDialAndSendWithContext() Signature 1 func (*Client) DialAndSendWithContext(context.Context, ...*Msg) error Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { from := \u0026#34;Toni Tester \u0026lt;toni@example.com\u0026gt;\u0026#34; to := \u0026#34;Alice \u0026lt;alice@example.com\u0026gt;\u0026#34; server := \u0026#34;mail.example.com\u0026#34; m := mail.NewMsg() if err := m.From(from); err != nil { panic(err) } if err := m.To(to); err != nil { panic(err) } m.Subject(\u0026#34;This is a great subject\u0026#34;) c, err := mail.NewClient(server) if err != nil { panic(err) } ctx := context.Background() if err := c.DialAndSendWithContext(ctx, m); err != nil { panic(err) } } Die WählenUndSendenMitKontext() ist eine Abkürzungsmethode für den Client. Sobald der Client erstellt ist, wird er sich durch den Aufruf der Methode DialAndSendWithContext() mit dem konfigurierten Server verbinden, die angegebene Mail Msg verschicken und zum Schluss die Verbindung wieder schließen.\nDas erste Argument der Methode ist ein context.Context, gefolgt von einer Liste von einem oder mehreren Msg Pointern. DialAndSendWithContext() gibt einen error zurück, wenn eine der durchgeführten Aktionen fehlschlägt.\n"},{"id":7,"href":"/de/tags/","title":"Tags","parent":"Willkommen in der go-mail-Dokumentation","content":""},{"id":8,"href":"/de/","title":"Willkommen in der go-mail-Dokumentation","parent":"","content":" go-mail ist eine einfach zu benutzende Go-Bibliothek zum Formatieren und Versenden von E-Mails. Es verwerndet einen idomatischen Go-Stil und folgt \u0026ldquo;Best Practices\u0026rdquo; mit vernünftigen Standards. Die Bibliothek hängt nur von der Go-Standardbibliothek ab.\ngo-mail funktioniert wie ein programmatischer E-Mail-Client und bietet viele Methoden und Funktionalitäten, die Du als Standard in einem E-Mail-Programm betrachten würdest.\nErste Schritte mit go-mail Funktions-Highlights Nur abhängig von der Standard-Bibliothek go-mail benötigt keine Module von Drittanbietern und basiert ausschließlich auf der Go-Standardbibliothek Modern, idiomatisch Wir verwenden moderne und idiotmatische Go-Standards mit dieser Bibliothek und folgen den modernsten bewährten -Verfahren mit vernünftigen Standardeinstellungen Vollständiger TLS-Support go-mail unterstützt implizite STARTTLS mit verschiedenen Richtlinien sowie explizite SSL/TLS für Verbindungen zum Senden von Mail-Servern Kontexte Wir verwenden Go-Kontexte für einen besseren Kontrollfluss und die Handhabung von Timeouts/Abbrüchen SMTP-Authentifizierung Unterstützung für drei gängige SMTP-Authentifizierungsmechanismen (LOGIN, PLAIN, CRAM-MD5) sowie für benutzerdefinierte Authentifizierungen. Überprüfung von E-Mail-Adressen go-mail folgt RFC5322 und validiert die angegebenen Mailadressen Unterstützung allgemeiner Mail-Header go-mail bringt Generatoren für viele gängige Mail-Header mit (Message-ID, Datum, Bulk-Precedence, Priority, etc.) Wiederverwendung von Verbindungen Du kannst mehrere Mails über dieselbe SMTP-Verbindung senden Anhänge/Einbettungen Volle Unterstützung für Anhänge und Inline-Einbettungen aus verschiedenen Quellen (lokales Dateisystem, io.Reader oder embed.FS) Kodierungen und Inhaltsarten go-mail unterstützt standardmäßig verschiedene Kodierungen und Inhaltstypen Middlewares Middleware-Unterstützung für Bibliotheken von Drittanbietern, um E-Mail-Nachrichten an ihre Bedürfnisse anzupassen Sendmail und Dateispeicherung Unterstützung für den Versand von E-Mail-Nachrichten über eine lokale sendmail-Installation sowie die Ausgabe in lokale Dateien (z. B. als .eml-Dateien auf der Festplatte, um sie in einem MUA zu öffnen) MDNs und DSNs go-mail bietet Unterstützung für die Abfrage von MDNs (RFC 8098) und DSNs (RFC 1891) Template-Unterstützung Unterstützung für Go\u0026rsquo;s html/template und text/template (als Nachrichtentext, alternativer Teil oder Anhang/Embedded) Unterstützung Wir haben einen Support- und allgemeinen Diskussionskanal auf dem Gophers Discord-Server. Du findest uns unter: #go-mail\n"}]