[{"id":0,"href":"/examples/","title":"Examples","parent":"Welcome to the go-mail documentation","content":""},{"id":1,"href":"/getting-started/","title":"Getting started","parent":"Welcome to the go-mail documentation","content":""},{"id":2,"href":"/getting-started/introduction/","title":"Introduction","parent":"Getting started","content":"This short tutorial shows you how to get up and running with go-mail from installation to sending your first mail.\nRequirements Installation Sending your first mail Create a new message Sending the mail Conclusion Full example code Requirements go-mail requires a working Go installation (Version 1.16+). Download Go from the Go Downloads Page.\nInstallation go-mail can be installed using the Go module installation mechanism via the go get command.\nTo install the latest version of go-mail, enter your project folder and simply import the module by issuing the following command:\n1 $ go get github.com/wneessen/go-mail Sending your first mail go-mail consists of two main components. The Msg which represents the mail message and the Client which takes care of the mail delivery via a SMTP service.\nCreate a new message First let\u0026rsquo;s create a new Msg using the NewMsg() method and assign a sender address as well as a recipient address.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;github.com/wneessen/go-mail\u0026#34; \u0026#34;log\u0026#34; ) func main() { m := mail.NewMsg() if err := m.From(\u0026#34;toni.sender@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set From address: %s\u0026#34;, err) } if err := m.To(\u0026#34;tina.recipient@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set To address: %s\u0026#34;, err) } } In this little code snippet, first and foremost we import go-mail into our project. See the import statement in line 4. Next we create a new message in line 9. Lines 10 and 13 set the sender and recipient addresses. Since go-mail makes sure that you are providing valid mail addresses, we return an error. This way we can make sure that the provided address is accepted by go-mail and will not cause problems later on.\nNext we want to set a subject line for our message and fill the mail body with some content.\n1 2 m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Do you like this mail? I certainly do!\u0026#34;) The first argument for SetBodyString() is a content type we need to provide. In our example the mail.TypeTextPlain basically represents a text/plain content type - meaning a plain text mail body.\nSending the mail Now that we have our mail message ready to go, let\u0026rsquo;s bring it on the way and send it out. For this we\u0026rsquo;ll use the Client, which handles the SMTP transmission.\n1 2 3 4 5 c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } In this example we connect to the mail server with the hostname smtp.example.com and provide the Client with a couple of options like the port we want to connect to, the fact that we want to use SMTP PLAIN for authentication and the username and password.\nFinally we tell the client to deliver the mail.\n1 2 3 if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } The DialAndSend() method takes care of establishing the connection and sending out the mail. You have the option to call them separately as well, but we won\u0026rsquo;t need this for the quick example.\nConclusion That was quite simple, wasn\u0026rsquo;t it? You successfully prepared a mail message and delivered it to the recipient via a 3rd party mail server. go-mail of course can do much more. Check out the in-depth documentation for all the features.\nFull example code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;github.com/wneessen/go-mail\u0026#34; \u0026#34;log\u0026#34; ) func main() { m := mail.NewMsg() if err := m.From(\u0026#34;toni.sender@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set From address: %s\u0026#34;, err) } if err := m.To(\u0026#34;tina.recipient@example.com\u0026#34;); err != nil { log.Fatalf(\u0026#34;failed to set To address: %s\u0026#34;, err) } m.Subject(\u0026#34;This is my first mail with go-mail!\u0026#34;) m.SetBodyString(mail.TypeTextPlain, \u0026#34;Do you like this mail? I certainly do!\u0026#34;) c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithPort(25), mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithUsername(\u0026#34;my_username\u0026#34;), mail.WithPassword(\u0026#34;extremely_secret_pass\u0026#34;)) if err != nil { log.Fatalf(\u0026#34;failed to create mail client: %s\u0026#34;, err) } if err := c.DialAndSend(m); err != nil { log.Fatalf(\u0026#34;failed to send mail: %s\u0026#34;, err) } } "},{"id":3,"href":"/reference/","title":"Reference","parent":"Welcome to the go-mail documentation","content":""},{"id":4,"href":"/examples/bulk-mailer/","title":"Bulk Mailer Example","parent":"Examples","content":"In this example we create a small bulk mailer for sending out the same mail to a bigger list of recipients. It is important for us to address the recipient directly in the mail, therefore we will also make use of Go\u0026rsquo;s text/template system.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; \u0026#34;text/template\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/wneessen/go-mail\u0026#34; ) // User is a simple type allowing us to set a firstname, lastname and mail address type User struct { Firstname string Lastname string EmailAddr string } // Our sender information that will be used in the FROM address field const ( senderName = \u0026#34;ACME Inc.\u0026#34; senderAddr = \u0026#34;noreply@acme.com\u0026#34; ) const mailBodyTemplate = `Hi {{.Firstname}}, we are writing your to let you know that this week we have an amazing offer for you. Using the coupon code \u0026#34;GOMAIL\u0026#34; you will get a 20% discount on all our products in our online shop. Check out our latest offer on https://acme.com and use your discount code today! Your marketing team at ACME Inc.` func main() { ul := []User{ {\u0026#34;Toni\u0026#34;, \u0026#34;Tester\u0026#34;, \u0026#34;toni.tester@example.com\u0026#34;}, {\u0026#34;Tina\u0026#34;, \u0026#34;Tester\u0026#34;, \u0026#34;tina.tester@example.com\u0026#34;}, {\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, \u0026#34;john.doe@example.com\u0026#34;}, } tpl, err := template.New(\u0026#34;template\u0026#34;).Parse(mailBodyTemplate) if err != nil { log.Fatalf(\u0026#34;failed to parse text template: %s\u0026#34;, err) } var ms []*mail.Msg r := rand.New(rand.NewSource(time.Now().UnixNano())) for _, u := range ul { rn := r.Int31() m := mail.NewMsg() if err := m.EnvelopeFrom(fmt.Sprintf(\u0026#34;noreply+%d@acme.com\u0026#34;, rn)); err != nil { log.Fatalf(\u0026#34;failed to set ENVELOPE FROM address: %s\u0026#34;, err) } if err := m.FromFormat(senderName, senderAddr); err != nil { log.Fatalf(\u0026#34;failed to set formatted FROM address: %s\u0026#34;, err) } if err := m.AddToFormat(fmt.Sprintf(\u0026#34;%s %s\u0026#34;, u.Firstname, u.Lastname), u.EmailAddr); err != nil { log.Fatalf(\u0026#34;failed to set formatted TO address: %s\u0026#34;, err) } m.SetMessageID() m.SetDate() m.SetBulk() m.Subject(fmt.Sprintf(\u0026#34;%s, we have a great offer for you!\u0026#34;, u.Firstname)) if err := m.SetBodyTextTemplate(tpl, u); err != nil { log.Fatalf(\u0026#34;failed to set template as text body: %s\u0026#34;, err) } ms = append(ms, m) } c, err := mail.NewClient(\u0026#34;smtp.example.com\u0026#34;, mail.WithSMTPAuth(mail.SMTPAuthPlain), mail.WithTLSPolicy(mail.TLSMandatory), mail.WithUsername(os.Getenv(\u0026#34;SMTP_USER\u0026#34;)), mail.WithPassword(os.Getenv(\u0026#34;SMTP_PASS\u0026#34;)), ) if err := c.DialAndSend(ms...); err != nil { log.Fatalf(\u0026#34;failed to deliver mail: %s\u0026#34;, err) } log.Printf(\u0026#34;Bulk mailing successfully delivered.\u0026#34;) } Let\u0026rsquo;s take the example apart to look at some details\u0026hellip;\nAt first, in line 15, we define a new type for our users that we want to address. This is totally optional and is only done so we can easily work with a list of users and address them later on in our text template. How you handle this, is totally up to you and not mandatory for this to work.\nIn line 27 we set up a simple text template mail body with placeholders that can be used with Go\u0026rsquo;s text/template. If you like you can also do this in HTML and use html/template instead. In this case you would use m.SetBodyHTMLTemplate instead of m.SetBodyTextTemplate in line 67. Of course both can be combined as well. For this we have the Msg.AddAlternativeHTMLTemplate and Msg.AddAlternativeTextTemplate methods.\nNext we set up a list of users, we want to send our great bulk mailing to. Line 39 uses the User type for this. With the preparation work done, we will start looping over all of our users in line 51. For each user we create a new *mail.Msg.\nFor bulk mailings it is common that the ENVELOPE FROM and the MAIL FROM differ, so that bounce mails are sent to some system that can mark those bounces in the local system as bounced. Therefore we set both of those from addresses in line 54 and line 57. The lines 60 to 66 should be of no surprise to you, if you already used go-mail before.\nOne more interesting thing happens in line 67 in which we use our prepared text/template and apply it to our mail message using m.SetBodyTextTemplate. We provide the whole user struct as data to that method, so that text/template can take care of replacing placeholders in the mail body. Go-mail will take care of all the bells and whistles with the template handling for you. With our mail message now complete, we append it to our mail message slice in line 71.\nFinally we create a new Client and send out all of our prepared messages in one go by providing the whole slice of messages to Client.DialAndSend.\n"},{"id":5,"href":"/reference/client/options/","title":"Client options","parent":"The mail delivery client","content":" Option WithDSN() WithDSNMailReturnType() WithDSNRcptNotifyType() WithHELO() Option Signature 1 type Option func(*Client) error Client Option are functions that can be used as optional arguments for the NewClient() methods to override the default vaules of the returned Client.\nWithDSN() Signature 1 func WithDSN() Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSN()) if err != nil { panic(err) } } The WithDSN option function tells the Client to request DSNs (if the server supports it) as described in RFC 1891.\nDSNs (Delivery Status Notification) are an extension to the SMTP protocol and need to be supported by the sending server. The RFC for DSNs defines different parameters of which we\u0026rsquo;ve implemented the once which we think make most sense for go-mail:\nThe RET extension for the MAIL FROM command, to let the user specify if a DSN should contain the full mail (FULL) or only headers (HDRS) of the sent mail. The NOTIFY extension that allows the user to request a DSN for the different types of allowed situations: NEVER, SUCCESS, FAILURE and DELAY ENVID and ORCPT are currently not supported but might follow in a later relaese (please open an issue if you see usefulness in this).\nBy default WithDSN() sets the FULL Mail From Return Option and the SUCCESS and FAILURE Recipient Notify Options. If you like to use other settings for the DSN, please see the documentation for WithDSNMailReturnType and WithDSNRcptNotifyType\nWithDSNMailReturnType() Signature 1 func WithDSNMailReturnType(DSNMailReturnOption) Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSNMailReturnType(mail.DSNMailReturnFull)) if err != nil { panic(err) } } WithDSNMailReturnType enables the Client to request DSNs (if the server supports it) as described in the RFC 1891 and set the MAIL FROM Return option type to the given DSNMailReturnOption\ngo-mail has the following two DSNMailReturnOption type already built-in:\nDSNMailReturnHeadersOnly: requests that only the headers of the message be returned. See: RFC 1891, Section 5.3 DSNMailReturnFull: requests that the entire message be returned in any \u0026ldquo;failed\u0026rdquo; delivery status notification issued for this recipient See: RFC 1891, Section 5.3 WithDSNRcptNotifyType() Signature 1 func WithDSNRcptNotifyType(...DSNRcptNotifyOption) Option Example 1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithDSNRcptNotifyType(mail.DSNRcptNotifyFailure, mail.DSNRcptNotifyDelay, mail.DSNRcptNotifySuccess)) if err != nil { panic(err) } } WithDSNRcptNotifyType enables the Client to request DSNs as described in RFC 1891 and sets the RCPT TO notify options to the given list of DSNRcptNotifyOption\ngo-mail has the following DSNRcptNotifyOption types already built-in:\nDSNRcptNotifyNever: requests that a DSN not be returned to the sender under any conditions. See: RFC 1891, Section 5.1 DSNRcptNotifySuccess: requests that a DSN be issued on successful delivery See: RFC 1891, Section 5.1 DSNRcptNotifyFailure: requests that a DSN be issued on delivery failure See: RFC 1891, Section 5.1 DSNRcptNotifyDelay: indicates the sender\u0026rsquo;s willingness to receive \u0026ldquo;delayed\u0026rdquo; DSNs. Delayed DSNs may be issued if delivery of a message has been delayed for an unusual amount of time (as determined by the MTA at which the message is delayed), but the final delivery status (whether successful or failure) cannot be determined. The absence of the DELAY keyword in a NOTIFY parameter requests that a \u0026ldquo;delayed\u0026rdquo; DSN NOT be issued under any conditions. See: RFC 1891, Section 5.1 WithHELO() Signature 1 func WithHELO(string) Option Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;, mail.WithHELO(\u0026#34;test.example.com\u0026#34;)) if err != nil { panic(err) } } WithHELO instructs the Client to use the provided string as HELO/EHLO greeting host. By default the Client will use Go\u0026rsquo;s os.Hostname() method to get the local hostname and use that for the HELO/EHLO greeting. WithHELO will override this.\n"},{"id":6,"href":"/community/","title":"Communities","parent":"Welcome to the go-mail documentation","content":""},{"id":7,"href":"/community/guide/","title":"Community Guide","parent":"Communities","content":"The go-mail community is growing and if you\u0026rsquo;re reading this, chances are that you want to join, too!\nResources Code of Conduct Support- and annoucement channels Contributing Developing New Features Fixing bugs Testing Documentation Translation Support Resources Code of Conduct In our community, we follow our Code of Conduct and ask everybody who likes to participate to act accordingly.\nSupport- and annoucement channels Twitter: Follow us on Twitter to receive recent news about go-mail go-mail forum: Receive announcements and start discussions about go-mail. Github issues: If you have a bug to report or feature to request, please use GitHub issues. Please respect the rules specified in each repository\u0026rsquo;s issue template. Discord: A place for go-mail devs and users to meet and chat in real time. Contributing go-mail is an open source, community driven project. We welcome anyone to join us in contributing to the project. This documentation is aimed at anyone wishing to get familiar with the project and the development processes.\nDeveloping new features Fixing bugs Testing Documenation Translation Support Developing New Features We are always keen to add features to go-mail. The process for adding new features are as follows:\nCheck the issue section on Github for available issues with the \u0026ldquo;TODO\u0026rdquo; or \u0026ldquo;help wanted\u0026rdquo; tag If no open \u0026ldquo;TODO\u0026rdquo;/\u0026ldquo;help wanted\u0026rdquo; issue is found or the feature you have in mind is not covered, please open a proposal issue for that specific feature and wait for the \u0026ldquo;OK\u0026rdquo; from the project maintainers Before developing, check that the issue includes the following information: The purpose of the enhancement What is out of scope for the enhancement If the issue does not include this information, feel free to request the information from the person who opened the issue. Sometimes placeholder issues are created and require more details Comment on the issue stating if you wish to develop the feature Clone the repository and create a branch with the format feature/\u0026lt;issue_number\u0026gt;_\u0026lt;issue_title\u0026gt; New features often require documentation so please ensure you have also added or updated the documentation as part of the changes Please make sure that your code has the required test coverage Once the feature is ready for testing, create a draft PR. Please ensure the PR description has the test scenarios and test cases listed with checkmarks, so that others can know what still needs to be tested Once all the testing is completed, please update the status of the PR from draft and leave a message Any PRs opened without a corresponding issue may be rejected. Fixing bugs The process for fixing bugs are as follows:\nCheck the Github issues and select a bug to fix Before developing, check that the issue includes the following information: The scope of the issue including platforms affected The steps to reproduce. Sometimes bugs are opened that are not go-mail issues and the onus is on the reporter to prove that it is a go-mail issue with a minimal reproducible example If the issue does not include this information, feel free to request the information from the person who opened the issue Comment on the issue stating you wish to develop a fix Clone the repository and create a branch with the format bugfix/\u0026lt;issue_number\u0026gt;_\u0026lt;issue_title\u0026gt; Once the fix is ready for testing, create a draft PR. Please ensure the PR description has the test scenarios and test cases listed with checkmarks, so that others can know what still needs to be tested Once all the testing is completed, please update the status of the PR from draft and leave a message. There is nothing stopping you from opening a issue and working on it yourself, but please be aware that all bugfixes should be discussed as the approach may have unintended side effects. Any PRs opened without a corresponding issue may be rejected. Testing Testing is vitally important to ensure quality in the project. There are a couple of scenarios where testing can really help the project:\nTesting if a bug is reproducible on your local system Testing PRs to ensure that they work correctly If you chose to test if someone\u0026rsquo;s bug report is reproducible on your local system, then feel free to add a comment on the issue confirming this with the output of your test program.\nTo test PRs, choose a PR to test and check if the PR description has the testing scenarios listed. If not, please ask the person who opened the PR to provide that list. Once you have determined a valid test scenario, please report your findings on the PR.\nIf you ever need more clarity or help on testing, please ask a question in the Github forum or on Discord.\nDocumentation While we require proper GoDoc documenation comments in the code, this website is meant as more in-depth documenation of features and the project itself.\nSince documenattion is hard and the website is still in an incomplete state, any contribution to this is greatly appreciated. Features without documentation are condidered \u0026ldquo;unfinished\u0026rdquo; to the project, it\u0026rsquo;s as important as the code.\nThe website is built on Hugo using the Geekdocs theme. It\u0026rsquo;s very simple and basically consists of markdown files. There are instructions on how to install the website on your local computer in the website\u0026rsquo;s repository.\nTranslation The default documents of the go-mail project are English documents. We use the \u0026ldquo;Crowdin\u0026rdquo; tool to translate documents in other languages and synchronize them to the website. You can join our project and submit your translations to make contributions.\nCurrently the only supported 2nd language is German, but we are keen to add other languages as well. Please request them via a Github issue in the go-mail-website repository.\nSupport A great way to contribute to the project is to help others who are experiencing difficulty. This is normally reported as a issue or a message on the #go-mail Discord channel. Even just clarifying the issue can really help out. Sometimes, when an issue is discussed and gets resolved, we create a guide out of it to help others who face the same issues.\n"},{"id":8,"href":"/tags/","title":"Tags","parent":"Welcome to the go-mail documentation","content":""},{"id":9,"href":"/reference/client/","title":"The mail delivery client","parent":"Reference","content":"In go-mail the Client is responsible for the mail delivery with remote mail servers that communicate via the SMTP protocol.\nNewClient() Client Close() DialAndSend() DialAndSendWithContext() NewClient() Signature 1 func NewClient(string, ...Option) (*Client, error) Example 1 2 3 4 5 6 7 8 9 10 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;) if err != nil { panic(err) } } To create a new Client, you can use the NewClient() method. As first argument it requires the hostname of the sending SMTP server. Optionally you can provide a list of Option funcionts. These option functions can be used to override the default settings of the Client.\nCheck the Options documentation for in-depth details to all available Options.\nClient Signature 1 2 3 type Client struct { // contains filtered or unexported fields } Close() Signature 1 func (*Client) Close() error Example 1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { c, err := mail.NewClient(\u0026#34;mail.example.com\u0026#34;) if err != nil { panic(err) } defer c.Close() } Close() closes the connection to the SMTP server the Client is connected to. It returns an error in case the Client has no active connection or if closing the connection fails.\nDialAndSend() Signature 1 func (*Client) DialAndSend(...*Msg) error Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { from := \u0026#34;Toni Tester \u0026lt;toni@example.com\u0026gt;\u0026#34; to := \u0026#34;Alice \u0026lt;alice@example.com\u0026gt;\u0026#34; server := \u0026#34;mail.example.com\u0026#34; m := mail.NewMsg() if err := m.From(from); err != nil { panic(err) } if err := m.To(to); err != nil { panic(err) } m.Subject(\u0026#34;This is a great subject\u0026#34;) c, err := mail.NewClient(server) if err != nil { panic(err) } if err := c.DialAndSend(m); err != nil { panic(err) } } The DialAndSend() method is an alias for DialAndSendWithContext() with a default context.Background context. DialAndSend() takes a list of Msg pointer as argument(s) and returns an error in case any of the performed actions fails.\nDialAndSendWithContext() Signature 1 func (*Client) DialAndSendWithContext(context.Context, ...*Msg) error Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;github.com/wneessen/go-mail\u0026#34; func main() { from := \u0026#34;Toni Tester \u0026lt;toni@example.com\u0026gt;\u0026#34; to := \u0026#34;Alice \u0026lt;alice@example.com\u0026gt;\u0026#34; server := \u0026#34;mail.example.com\u0026#34; m := mail.NewMsg() if err := m.From(from); err != nil { panic(err) } if err := m.To(to); err != nil { panic(err) } m.Subject(\u0026#34;This is a great subject\u0026#34;) c, err := mail.NewClient(server) if err != nil { panic(err) } ctx := context.Background() if err := c.DialAndSendWithContext(ctx, m); err != nil { panic(err) } } The DialAndSendWithContext() is a one-for-all shortcut method on the Client. Once the Client is created, calling the DialAndSendWithContext() method will have it connect to the configured server, send out the given mail Msg and finalize by closing the connection again.\nThe first argument of the method is a context.Context followed by a list of one or more Msg pointers. DialAndSendWithContext() does return an error in case any of the performed actions fails.\n"},{"id":10,"href":"/","title":"Welcome to the go-mail documentation","parent":"","content":" go-mail is an easy to use Go library for formating and sending mails. It uses idiomatic Go style and follows best practice with sane defaults. The library only dependends on the Go Standard Library.\ngo-mail works like a programatic email client and provides lots of methods and functionalities you would consider standard in a MUA.\nGet started using go-mail Feature highlights Standard Library dependant go-mail does not require any third-party modules and only runs on the Go standard library Modern, idiomatic Go We are using modern and idiotmatic Go standards with this library and follow state-of-the-art best practices with sane defaults Full TLS support go-mail supports implicit STARTTLS with different policies as well as explicit SSL/TLS for connections to sending mail servers Contexts We make use of Go contexts for better control flow and timeout/cancelation handling SMTP Authentication Support for three common SMTP authentication mechanisms (LOGIN, PLAIN, CRAM-MD5) as well as custom authentications. Mail address validation go-mail follows RFC5322 and validates the provided mail addresses Common mail header support go-mail brings generators for lots of common mail headers (Message-ID, Date, Bulk-Precedence, Priority, etc.) Connection reusing You can send mulitple mails over the same SMTP connection Attachments/Embeds Full support for attachments and inline embeds from different sources (local file system, io.Reader or embed.FS) Encodings and content types go-mail supports different encondings and content types out of the box Middlewares Middleware support for 3rd-party libraries to alter mail message to their need Sendmail and file storage Support for sending mail messages through a local sendmail installation as well as output to local files (e. g. as .eml files to disk to open them in a MUA) MDNs and DSNs go-mail brings support for requestng MDNs (RFC 8098) and DSNs (RFC 1891) Template support Support for Go\u0026rsquo;s html/template and text/template (as message body, alternative part or attachment/emebed) DKIM support DKIM signature support via the go-mail-middlware/dkim middleware Support We have a support and general discussion channel on the Gophers Discord server. Find us at: #go-mail\n"}]